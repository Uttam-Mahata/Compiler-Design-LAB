# Assignment-06-TCG Quick Start Guide

## Files Copied from Assignment-05-ICG

The following files were copied to create a complete pipeline:

1. **lex.l** - Lexical analyzer (Flex)
2. **parse.y** - Parser with ICG (Bison/YACC)
3. **icg.h** / **icg.c** - Intermediate Code Generation module
4. **symbol_table.h** / **symbol_table.c** - Symbol table management
5. **test_*.c** - C source test files

## Quick Commands

### Build Everything
```bash
make clean
make
```

### Test Code Generator with Pre-generated TAC
```bash
./codegen test1_tac.txt    # Assignment statements
./codegen test2_tac.txt    # Arithmetic expressions
./codegen test3_tac.txt    # If statement
./codegen test4_tac.txt    # While loop
./codegen test5_tac.txt    # Comprehensive
```

### Full Pipeline (C → TAC → Assembly)
```bash
make pipeline               # Uses test_comprehensive.c
```

### Generate TAC from C Source
```bash
./icg_compiler < test_assignment.c
./icg_compiler < test_while.c
```

### Then Generate Assembly from TAC
```bash
./codegen three_address_code.txt
```

## Output Files

- **three_address_code.txt** - Generated by icg_compiler
- **assembly_code.asm** - Generated by codegen

## Example Workflow

```bash
# Step 1: Write C code
cat > my_program.c << EOF
int main() {
    int a, b, sum;
    a = 10;
    b = 20;
    sum = a + b;
}
EOF

# Step 2: Generate three-address code
./icg_compiler < my_program.c

# Step 3: Generate assembly code
./codegen three_address_code.txt

# Step 4: View results
cat three_address_code.txt
cat assembly_code.asm
```

## Key Features

### Register Allocation
- 4 general-purpose registers (R0-R3)
- Automatic spilling when needed
- Reuses registers for dead variables
- Implements Aho-Sethi-Ullman getReg() algorithm

### Supported Operations
- Assignments (=)
- Arithmetic (+, -, *, /)
- Unary minus (uminus)
- Labels (label_begin, label_end)
- Conditional jumps (ifFalse)
- Unconditional jumps (goto)

### Assembly Instructions Generated
- **LD** - Load (register from memory/constant)
- **ST** - Store (memory from register)
- **ADD, SUB, MUL, DIV** - Arithmetic operations
- **NEG** - Unary minus
- **CMP** - Compare
- **JE** - Jump if equal (conditional)
- **JMP** - Unconditional jump
- **HALT** - End program

## Test Results Summary

### Test 1: Assignment Statements (a = 10; b = 20; c = a + b;)
- ✅ Loads constants correctly
- ✅ Performs addition
- ✅ Stores results

### Test 2: Arithmetic with Unary Minus
- ✅ Handles unary minus (NEG instruction)
- ✅ Complex expressions evaluated correctly

### Test 3: If Statement
- ✅ Conditional jump generated
- ✅ Labels placed correctly

### Test 4: While Loop
- ✅ Loop label at beginning
- ✅ Condition check and jump
- ✅ Back jump to loop start
- ✅ Exit label after loop

### Test 5: Comprehensive (If-Else + While)
- ✅ Multiple control structures
- ✅ Nested constructs handled
- ✅ Register management across structures

## Troubleshooting

### Segmentation Fault in ICG Compiler
The ICG compiler from Assignment-05 may have issues with some inputs. Use the pre-generated TAC files in test*_tac.txt instead.

### Empty Result Fields
Fixed in latest version - now properly parses whitespace-separated quadruples.

### Register Exhaustion
With only 4 registers, complex expressions may cause spilling. This is expected and handled automatically.

## Architecture Diagram

```
C Source Code
     ↓
[lex.l + parse.y]  ← Assignment-05-ICG
     ↓
Three-Address Code
     ↓
[codegen.c]        ← Assignment-06-TCG (This Assignment)
     ↓
Assembly Code
```

## Implementation Highlights

1. **Quadruple Parsing** - Flexible whitespace handling
2. **Register Descriptors** - Track register contents
3. **Address Descriptors** - Track variable locations
4. **getReg() Algorithm** - Smart register allocation
5. **Spilling Strategy** - Priority-based selection
6. **Code Emission** - Clean assembly with comments

## References

- Aho, Sethi, Ullman - "Compilers: Principles, Techniques, and Tools"
- Chapter 8: Code Generation, pp 535-541
- 8085/8086 Instruction Set Reference
