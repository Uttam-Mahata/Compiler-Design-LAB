# Code Flow Explanation: How the Compiler Components Work Together

## Table of Contents
1. [Program Initialization](#program-initialization)
2. [Lexical Analysis Process](#lexical-analysis-process)
3. [Parsing and Symbol Table Integration](#parsing-and-symbol-table-integration)
4. [Type Checking Mechanism](#type-checking-mechanism)
5. [Scope Management](#scope-management)
6. [Complete Execution Flow Examples](#complete-execution-flow-examples)

---

## Program Initialization

### Entry Point: `main()` function in `parse.y`

```c
int main() {
    printf("Starting parser...\n");
    yyparse();  // Calls the parser generated by Yacc
    
    if (error_count == 0) {
        printf("\nParsing completed successfully!\n");
        print_symbol_table();
    } else {
        printf("\nParsing completed with %d error(s)\n", error_count);
    }
    
    return 0;
}
```

**What happens:**
1. Program starts execution from `main()`
2. Calls `yyparse()` which is the parser function generated by Yacc from `parse.y`
3. `yyparse()` internally calls `yylex()` to get tokens
4. After parsing completes, checks if there were errors
5. If no errors, prints the symbol table; otherwise shows error count

---

## Lexical Analysis Process

### How the Lexer Works (`lex.l`)

The lexer uses pattern matching to convert source code into tokens. Here's the detailed flow:

### Step 1: Pattern Recognition

When source code like `int x = 5;` is encountered:

```
Character Stream: i n t   x   =   5 ;
                  ↓ ↓ ↓   ↓   ↓   ↓ ↓
Pattern Matching: {letter}{alphanum}*
```

### Step 2: Keyword vs Identifier Detection

```c
{letter}{alphanum}* {
    // First check length
    if (strlen(yytext) > MAX_ID_LENGTH) {
        print_error("Identifier too long", yytext);
        return ID_TOO_LONG_ERROR;
    }
    
    // Check for spelling errors
    int spelling_check = check_spelling_error(yytext);
    if (spelling_check) return spelling_check;
    
    // Store identifier name in yylval for parser to use
    yylval.string_val = strdup(yytext);
    
    // Check if it's a keyword or identifier
    return check_keyword(yytext);
}
```

### Step 3: `check_keyword()` Function

```c
int check_keyword(char* word) {
    if (strcmp(word, "int") == 0) return INT_TOK;
    if (strcmp(word, "float") == 0) return FLOAT_TOK;
    if (strcmp(word, "char") == 0) return CHAR_TOK;
    if (strcmp(word, "void") == 0) return VOID_TOK;
    if (strcmp(word, "while") == 0) return WHILE_TOK;
    if (strcmp(word, "for") == 0) return FOR_TOK;
    if (strcmp(word, "do") == 0) return DO_TOK;
    if (strcmp(word, "if") == 0) return IF_TOK;
    if (strcmp(word, "else") == 0) return ELSE_TOK;
    if (strcmp(word, "return") == 0) return RETURN_TOK;
    return ID_TOK;  // Not a keyword, so it's an identifier
}
```

**Process for `int x = 5;`:**

1. **"int"**: 
   - Matches `{letter}{alphanum}*`
   - `check_keyword("int")` returns `INT_TOK`
   - Parser receives `INT_TOK`

2. **"x"**: 
   - Matches `{letter}{alphanum}*`
   - `check_keyword("x")` returns `ID_TOK`
   - `yylval.string_val = "x"` (stores identifier name)
   - Parser receives `ID_TOK` with value "x"

3. **"="**: 
   - Matches exact pattern `"="`
   - Returns `ASSIGN_TOK`

4. **"5"**: 
   - Matches `{digit}+`
   - Converts to integer: `yylval.int_val = atoi("5")` = 5
   - Returns `INTCONST_TOK`

5. **";"**: 
   - Matches exact pattern `";"`
   - Returns `SEMICOLON_TOK`

---

## Parsing and Symbol Table Integration

### How Parser Rules Work

The parser uses grammar rules defined in `parse.y`. Let's trace `int x;`:

### Parser Grammar Rule:

```yacc
declaration_statement: data_type { current_type = token_to_type($1); } 
                       declarator_list SEMICOLON_TOK
                      { print_syntax_success("Local variable declaration"); }
```

### Execution Flow:

```
Token Stream: INT_TOK → ID_TOK("x") → SEMICOLON_TOK
                ↓           ↓              ↓
Parser Rule:  data_type  declarator  SEMICOLON_TOK
                ↓           ↓              ↓
Actions:    Set current_type  Add to symbol table  Print success
```

### Detailed Breakdown:

#### 1. `data_type` rule matches:
```yacc
data_type: INT_TOK { $$ = INT_TOK; }
```
- Parser receives `INT_TOK` from lexer
- Sets `$$ = INT_TOK` (return value of this rule)
- **Action in parent rule**: `current_type = token_to_type(INT_TOK)` → `current_type = TYPE_INT`

#### 2. `declarator` rule matches:
```yacc
declarator: ID_TOK {
    if (!add_symbol($1, current_type, get_current_scope_type(), 
                    line_number, 0)) {
        error_count++;
    }
    free($1);
}
```
- `$1` contains the string "x" (from `yylval.string_val`)
- Calls `add_symbol("x", TYPE_INT, SCOPE_GLOBAL, 1, 0)`

#### 3. Symbol Table Operation:

```c
int add_symbol(char* name, data_type_t type, scope_type_t scope, 
               int line_no, int is_function) {
    // Calls the extended version with default values
    return add_symbol_with_attrs(name, type, scope, line_no, 
                                 is_function, 0, 0, 0);
}
```

```c
int add_symbol_with_attrs(...) {
    // Check if symbol table is full
    if (sym_table.count >= MAX_SYMBOLS) {
        printf("ERROR: Symbol table overflow\n");
        return 0;
    }
    
    // Check for duplicate in current scope
    symbol_t* existing = lookup_symbol_in_scope(name, sym_table.current_scope_level);
    if (existing != NULL) {
        printf("ERROR (Line %d): Variable '%s' already declared...\n", ...);
        return 0;  // Duplicate found!
    }
    
    // Add new symbol
    strcpy(sym_table.symbols[sym_table.count].name, "x");
    sym_table.symbols[sym_table.count].type = TYPE_INT;
    sym_table.symbols[sym_table.count].scope = SCOPE_GLOBAL;
    sym_table.symbols[sym_table.count].scope_level = 0;
    sym_table.symbols[sym_table.count].line_declared = 1;
    sym_table.symbols[sym_table.count].is_function = 0;
    sym_table.symbols[sym_table.count].is_array = 0;
    sym_table.symbols[sym_table.count].array_size = 0;
    sym_table.symbols[sym_table.count].is_pointer = 0;
    
    printf("SYMBOL TABLE: Added 'x' - Type: int, Scope: global (Level 0), Line: 1\n");
    
    sym_table.count++;  // Now count = 1
    return 1;  // Success
}
```

---

## Type Checking Mechanism

### How Type Checking Works During Expression Evaluation

Let's trace: `x + y` where `x` is `int` and `y` is `float`

### Parser Expression Rule:

```yacc
additive_expr: multiplicative_expr ADD_TOK multiplicative_expr {
    // $1 = left operand expression info
    // $3 = right operand expression info
    
    data_type_t result_type = check_binary_op_type(
        $1.type,      // TYPE_INT
        $3.type,      // TYPE_FLOAT
        "+"
    );
    
    $$.type = result_type;
    $$.is_lvalue = 0;  // Result of addition is not an lvalue
}
```

### Type Checking Function:

```c
data_type_t check_binary_op_type(data_type_t left, data_type_t right, char* op) {
    // Step 1: Check if both operands are numeric
    if (!is_numeric_type(left) || !is_numeric_type(right)) {
        char msg[100];
        sprintf(msg, "Non-numeric operand for operator '%s'", op);
        print_type_error(msg);
        return TYPE_UNKNOWN;
    }
    
    // Step 2: Check type compatibility
    if (!are_types_compatible(left, right)) {
        char msg[100];
        sprintf(msg, "Type mismatch in binary operation '%s'", op);
        print_type_error(msg);
        return TYPE_UNKNOWN;
    }
    
    // Step 3: Return result type (promote to float if either is float)
    if (left == TYPE_FLOAT || right == TYPE_FLOAT) {
        return TYPE_FLOAT;
    }
    return left;
}
```

### Helper Functions:

```c
int is_numeric_type(data_type_t type) {
    data_type_t base = get_base_type(type);
    return (base == TYPE_INT || base == TYPE_FLOAT || base == TYPE_CHAR);
}

int are_types_compatible(data_type_t type1, data_type_t type2) {
    if (type1 == type2) return 1;
    
    data_type_t base1 = get_base_type(type1);
    data_type_t base2 = get_base_type(type2);
    
    // Numeric promotions: int and char are compatible
    if ((base1 == TYPE_INT || base1 == TYPE_CHAR) && 
        (base2 == TYPE_INT || base2 == TYPE_CHAR)) return 1;
    
    // Float is only compatible with float
    if (base1 == TYPE_FLOAT && base2 == TYPE_FLOAT) return 1;
    
    return 0;
}
```

### Execution for `x + y`:

1. **Parse `x`**:
   - Lexer returns `ID_TOK("x")`
   - Parser matches `primary_expr: ID_TOK` rule
   - Looks up "x" in symbol table → finds `TYPE_INT`
   - Sets `$$.type = TYPE_INT`, `$$.is_lvalue = 1`

2. **Parse `+`**:
   - Lexer returns `ADD_TOK`

3. **Parse `y`**:
   - Lexer returns `ID_TOK("y")`
   - Parser matches `primary_expr: ID_TOK` rule
   - Looks up "y" in symbol table → finds `TYPE_FLOAT`
   - Sets `$$.type = TYPE_FLOAT`, `$$.is_lvalue = 1`

4. **Type Check**:
   - Calls `check_binary_op_type(TYPE_INT, TYPE_FLOAT, "+")`
   - Both are numeric ✓
   - INT and FLOAT are NOT directly compatible ✗
   - **But wait!** The actual implementation might have implicit conversion rules
   - Result type: `TYPE_FLOAT` (promotion)

---

## Scope Management

### How Scopes are Created and Destroyed

### Data Structure:
```c
typedef struct {
    symbol_t symbols[MAX_SYMBOLS];  // Array of all symbols
    int count;                      // Number of symbols
    int current_scope_level;        // Current nesting level
} symbol_table_t;
```

### Scope Operations:

#### 1. **Entering a Scope** (e.g., function or compound statement):

```c
void enter_scope() {
    sym_table.current_scope_level++;
    printf("SCOPE: Entering scope level %d\n", sym_table.current_scope_level);
}
```

#### 2. **Exiting a Scope**:

```c
void exit_scope() {
    printf("SCOPE: Exiting scope level %d\n", sym_table.current_scope_level);
    
    // Remove all symbols declared in this scope
    int new_count = 0;
    for (int i = 0; i < sym_table.count; i++) {
        if (sym_table.symbols[i].scope_level < sym_table.current_scope_level) {
            // Keep this symbol (it's from outer scope)
            if (new_count != i) {
                sym_table.symbols[new_count] = sym_table.symbols[i];
            }
            new_count++;
        } else {
            // Remove this symbol (it's from current scope)
            printf("SYMBOL TABLE: Removing '%s' from scope level %d\n", 
                   sym_table.symbols[i].name, sym_table.symbols[i].scope_level);
        }
    }
    sym_table.count = new_count;
    
    sym_table.current_scope_level--;
}
```

### Parser Grammar with Scope:

```yacc
compound_statement: LBRACE_TOK 
                    { enter_scope(); }    // Create new scope
                    statement_list 
                    RBRACE_TOK
                    { exit_scope(); }     // Destroy scope
```

---

## Complete Execution Flow Examples

### Example 1: Simple Declaration and Assignment

**Source Code:**
```c
int x;
float y;
x = y + 5;
```

### Detailed Execution:

#### Phase 1: `int x;`

1. **Lexer**:
   - Reads 'i', 'n', 't' → matches `{letter}{alphanum}*`
   - Calls `check_keyword("int")` → returns `INT_TOK`
   
2. **Parser**:
   - Receives `INT_TOK`
   - Matches `data_type: INT_TOK` rule
   - Sets `current_type = TYPE_INT`
   
3. **Lexer**:
   - Reads 'x' → matches `{letter}{alphanum}*`
   - `yylval.string_val = strdup("x")`
   - Calls `check_keyword("x")` → returns `ID_TOK`
   
4. **Parser**:
   - Receives `ID_TOK` with value "x"
   - Matches `declarator: ID_TOK` rule
   - Calls `add_symbol("x", TYPE_INT, SCOPE_GLOBAL, 1, 0)`
   
5. **Symbol Table**:
   - Checks for duplicates → None found
   - Adds entry:
     ```
     symbols[0] = {
         name: "x",
         type: TYPE_INT,
         scope: SCOPE_GLOBAL,
         scope_level: 0,
         line_declared: 1,
         is_function: 0,
         is_array: 0,
         array_size: 0,
         is_pointer: 0
     }
     count = 1
     ```
   
6. **Lexer**:
   - Reads ';' → returns `SEMICOLON_TOK`
   
7. **Parser**:
   - Completes declaration rule
   - Prints: `SYNTAX OK (Line 1): Global variable declaration`

#### Phase 2: `float y;`

Similar process:
- Lexer: `FLOAT_TOK` → `ID_TOK("y")` → `SEMICOLON_TOK`
- Parser: Adds "y" to symbol table with `TYPE_FLOAT`
- Symbol table count becomes 2

#### Phase 3: `x = y + 5;`

1. **Parse Left Side (`x`)**:
   - Lexer: `ID_TOK("x")`
   - Parser: Looks up "x" → finds `TYPE_INT`
   - Expression info: `{type: TYPE_INT, is_lvalue: 1}`

2. **Parse Assignment Operator**:
   - Lexer: `ASSIGN_TOK`

3. **Parse Right Side (`y + 5`)**:
   
   a. **Parse `y`**:
      - Lexer: `ID_TOK("y")`
      - Parser: Looks up "y" → finds `TYPE_FLOAT`
      - Expression info: `{type: TYPE_FLOAT, is_lvalue: 1}`
   
   b. **Parse `+`**:
      - Lexer: `ADD_TOK`
   
   c. **Parse `5`**:
      - Lexer: `INTCONST_TOK` with value 5
      - Expression info: `{type: TYPE_INT, is_lvalue: 0}`
   
   d. **Type check `y + 5`**:
      - Calls `check_binary_op_type(TYPE_FLOAT, TYPE_INT, "+")`
      - Both numeric ✓
      - Result: `TYPE_FLOAT` (int promoted to float)

4. **Type Check Assignment `x = (y + 5)`**:
   ```c
   check_assignment_type(TYPE_INT,    // left (x)
                        TYPE_FLOAT,   // right (y+5)
                        1)            // x is lvalue
   ```
   - Left is lvalue ✓
   - **TYPE_INT ≠ TYPE_FLOAT** ✗
   - **ERROR**: Type mismatch in assignment

5. **Output**:
   ```
   TYPE ERROR (Line 3): Type mismatch in assignment
   ```

---

### Example 2: Function with Scope

**Source Code:**
```c
int main() {
    int x;
    {
        int y;
        x = y;
    }
    return 0;
}
```

### Scope Progression:

```
Scope Level 0 (Global):
├─ main (function)
│
Scope Level 1 (Function):
├─ x (local variable)
│
Scope Level 2 (Block):
├─ y (block variable)
│
After block exits:
└─ y removed
│
Scope Level 1 (Function):
└─ x still exists
```

### Execution Trace:

1. **`int main()`**:
   - Adds "main" to symbol table at level 0
   - Calls `enter_scope()` → level becomes 1
   - Output: `SCOPE: Entering scope level 1`

2. **`int x;`** (inside main):
   - Adds "x" at level 1
   - Symbol table:
     ```
     [0] main - level 0
     [1] x    - level 1
     ```

3. **`{`** (compound statement):
   - Calls `enter_scope()` → level becomes 2
   - Output: `SCOPE: Entering scope level 2`

4. **`int y;`** (inside block):
   - Adds "y" at level 2
   - Symbol table:
     ```
     [0] main - level 0
     [1] x    - level 1
     [2] y    - level 2
     ```

5. **`x = y;`**:
   - Looks up "x": Searches level 2 → not found, level 1 → found!
   - Looks up "y": Searches level 2 → found!
   - Both are `TYPE_INT`, assignment succeeds

6. **`}`** (end of block):
   - Calls `exit_scope()` → level becomes 1
   - Removes all symbols with level 2 ("y" is removed)
   - Output: `SYMBOL TABLE: Removing 'y' from scope level 2`
   - Symbol table:
     ```
     [0] main - level 0
     [1] x    - level 1
     ```

7. **`}`** (end of main):
   - Calls `exit_scope()` → level becomes 0
   - Removes all symbols with level 1 ("x" is removed)
   - Symbol table:
     ```
     [0] main - level 0
     ```

---

## Key Takeaways

### 1. **Token Flow**:
```
Source Code → Lexer (pattern matching) → Tokens → Parser (grammar rules) → Actions
```

### 2. **Symbol Table Integration**:
```
Parser encounters declaration → Calls add_symbol() → Symbol table checks duplicates → Stores if valid
Parser encounters identifier → Calls lookup_symbol() → Returns type info for type checking
```

### 3. **Type Checking**:
```
Expression parsed → Types extracted from symbol table → Compatibility checked → Result type determined
```

### 4. **Scope Management**:
```
{ encountered → enter_scope() (level++) → Symbols added at current level → } encountered → exit_scope() (remove symbols, level--)
```

### 5. **Error Handling**:
- **Lexical errors**: Detected in lexer (invalid characters, too long identifiers)
- **Syntax errors**: Detected by parser (missing semicolons, unmatched braces)
- **Semantic errors**: Detected during type checking (type mismatches, undeclared variables)

This architecture ensures clean separation of concerns while maintaining tight integration between components for comprehensive error detection and analysis.
